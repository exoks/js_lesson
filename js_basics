#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£§‚£¶‚£¥‚£∂‚£æ‚£ø‚£∂‚£∂‚£∂‚£∂‚£¶‚£§‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢†‚°∂‚†ª‚†õ‚†ü‚†ã‚†â‚†Ä‚†à‚†§‚†¥‚†∂‚†∂‚¢æ‚£ø‚£ø‚£ø‚£∑‚£¶‚†Ñ‚†Ä‚†Ä‚†Ä               ìêì  js_basics ìêî           
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†î‚†ã‚†Ä‚†Ä‚†§‚†í‚†í‚¢≤‚†Ä‚†Ä‚†Ä‚¢Ä‚£†‚£§‚£§‚£¨‚£Ω‚£ø‚£ø‚£ø‚£∑‚£Ñ‚†Ä‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚£Ä‚£é‚¢§‚£∂‚£æ‚†Ö‚†Ä‚†Ä‚¢Ä‚°§‚†è‚†Ä‚†Ä‚†Ä‚††‚£Ñ‚£à‚°ô‚†ª‚¢ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚†Ä   Student: oezzaou <oezzaou@student.1337.ma> 
#  ‚¢Ä‚†î‚†â‚†Ä‚†ä‚†ø‚†ø‚£ø‚†Ç‚††‚†¢‚£§‚†§‚£§‚£º‚£ø‚£∂‚£∂‚£§‚£ù‚£ª‚£∑‚£¶‚£ç‚°ª‚£ø‚£ø‚£ø‚£ø‚°Ä                                              
#  ‚¢æ‚£æ‚£Ü‚£§‚£§‚£Ñ‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†â‚¢ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á                                              
#  ‚†Ä‚†à‚¢ã‚¢π‚†ã‚†â‚†ô‚¢¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á       Created: 2025/01/19 08:16:53 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†ë‚†Ä‚†Ä‚†Ä‚†à‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†á       Updated: 2025/01/20 22:40:29 by oezzaou
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°á‚†Ä‚†Ä‚¢Ä‚£æ‚£ø‚£ø‚†ø‚†ü‚†õ‚†ã‚†õ‚¢ø‚£ø‚£ø‚†ª‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢Ä‚†á‚†Ä‚¢†‚£ø‚£ü‚£≠‚£§‚£∂‚£¶‚£Ñ‚°Ä‚†Ä‚†Ä‚†à‚†ª‚†Ä‚†ò‚£ø‚£ø‚£ø‚†á‚†Ä                                              
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†±‚†§‚†ä‚†Ä‚¢Ä‚£ø‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚†è‚†Ä‚†Ä                             ìÜ©‚ôïìÜ™      
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚°Ñ‚†Ä‚†Ä‚†Ä‚†ò‚¢ß‚°Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£ø‚†ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ê‚†ã‚†Ä‚†Ä‚†Ä                     ìÑÇ oussama ezzaouìÜÉ  
#  ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†ò‚†Ñ‚£Ä‚°Ä‚†∏‚†ì‚†Ä‚†Ä‚†Ä‚††‚†ü‚†ã‚†Å‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä                                              

====<{ js: basics }>===========================================================
> Javascript has been mainly designed for WEB PAGES, Make web pages dynamic
& interactive (example: button click, add-delete-edit page component)
> Javascript has been released since 1997
  - javascript versions:
  * ECMAScript1, 2, 3, 4, 5, 5.1, 6, 2016, 2017, 2018, 2019, ..., 2023
  - Javacript is considered an interpreter language, but it's engine (interpreter)
  use JIT technique to improve preformance
  - Javascript engine relies on garbage collector technique to prevent memory leaks

====<[ js: code rules ]>=========================
- Js is a <case sensitive>
- Js is <camel case>, means the first char must be lowercase & then uppercase
ex:
  - first 
  - firstName 
- ';' is optional in javascript, but it's recommended
- commants in js are the same as C/C++, Java
- variables names can start with (_, $, lowercase, uppercase)

====<[ js: how js works ? ]>=====================
> Js runs in two primary environments:
  - Browser Environment: Js is executed in the browser's javascript engine
    (V8 for chrome, SpiderMonky for Firefox)
  - Server Environment: javascript runs on servers using envs like Node.js

> Core Components
  1|_ Javascripts Engine
    * The engine compiles & executes Javascript code
    - V8 (used in chrome & node.js)
    - SpiderMonkey (used in Firefox)
    - JavaScriptCore (used in Safari)
  2|_ Steps in the Javascript engine
    1_ Parsing: The engine parses JavaScript code into AST
    2_ Compilation: Modern engines use JUST-IN-TIME(JIT) compilation to convert
      the AST into machine code
    3_ Execution: The compiled code is executed to perform tasks 

> Asynchronous Handling
  * Js is a single-threaded but can handle async operations using event-loop
  (execution pool)
    - callback functions
    - promises
    - async/await

===<{ Type of Compilations: }>==================================================
> [ ahead-of-time (AOT): ] ======================
  entire program compiled into machine code before execution
    ex: C/C++, RUST (compiled languages)
source code => preprocessor => compiler => assembler => linker => machine code (excutable) 

> [ Interpretation: ] ===========================
                            INTERPRETER (CPYTHON)
Source code => [ compiler  => virtual machine (lib modules) ] => Runing Code 

  * Parser of Compiler converts the source code into AST 
  * Compiler converts the AST into bytecode
  * PVM, reads the bytecode & interpretes instruction by instruction into machine code

# INFO: [ KNOW I UNDERSTAND PYTHON INTERPRETER ] 
# Compilation <From source code to bytecode>
  # Pyhton interpreter converts the entire script into bytecode.pyc(lower-level representation)
# Excution < by PVM>  (python interprers: CPython, PyPy, MicroPython) 
  # PVM takes the byte code & interpretes it INSTRUCTION BY INSTRUCTION
  # Each bytecode instruction is executed by dynamically converting it into machine code
# This technique is called traditinal interpretation or byte interpretation 

# NOTE::> what is the diff between bytecode & machine code
# bytecode: A low-level platform-independent code
#   - runs on virtual machine (pyhton virtual machine, JVM)
#   - examples: python compiles .py files to .pyc bytcode
# machinecode: A binary, platfrom-specific code
#   - runs directly on the CPU
#   - examples: C/C++ excutable 
#   - machinecode is what the CPU understand and directly executes without needing
#     further translation
# In Short, bytecode is an intermediate step, while machine code is the finable
# executable code for the hardware
#
> [ JUST-IN-TIME (JIT): ] =======================
                            Engine
  source code => [ compiler => interpreter => jit-compiler (detect hot code) ] => Runing code 
  * is a technique used by modern programming
    language interpreters & runtimes to improve performance by dynamically
    translating code into machine language (native code) during execution. 
  * engine JIT compiler is a little bit different from interprter compiler
    - it does parse the source code into AST
    - converts AST to (jit-compiled) bytecode  
    - jit-compiled code is executed by JVM javascript virtualmachine
    - engine during it's execution learns, and that help it optimize & fast execution
  # TIP:
  # Earyly in JS history, engines were the same as interpreter but this technique is too slow
  # Modern js engines use <HYPRED MODEL>, wich means start by interpreting the code,
  # then dynamically compile & optimize parts of is as they run,
  # offering a balance of initial speed & long-term preformace
  # In pure interpretation, the code is executed instruction by instruction.
  # In an engine with JIT compilation, it interprets first but compiles and optimizes
  # only the frequently executed parts into machine code for faster execution,
  # bypassing interpretation for those parts.
  # CONCLUSION: 
  # engines katparser source code l wahed AST,
  # lcompiler kihawlo l bytecode ohna fin katbda lkhedma 
  # kayched awel instraction or cold code tay executiha using iterpreter (for intitial speed)
  # mn ba3d ila l9a hot code tay3tiha l jit-compiler lit tayconverith l native machine code
  # ty excuta direct by cpu
  # jit-compiler bypass the need bytecode interpretation (o had l operation hiya li slow)
  # The engine can keep a cache of compiled native machine code for hot code,
  # so it doesn‚Äôt need to compile it again if it‚Äôs executed later. 
  # NOTE: 
  # interpreter in python uses the tradionnal (bytecode) interpretation technique
  # javascript use a modern interpreiation technique is called JIT
  # javascript interpreter is called Engine
  # INFO: 
  # Node js use V8 engine the one exist in google chrome for interpretation
================================================================================

=== Javascript in browser envirmment: ==========================================
- as we all know the javascript works or get executed in two main envirements
- server envirment: using node.js to execute it 
- browser envirment: in google chrome, firefox or safari ...

how to use javascript in browser envirmment ?
- you can use the interactive console of the browser to execute the js code
- to make HTML page more dynamic & interactive you could link it with js code 

There are Two methods to link javascript code with HTML page
# INFO: <script></script> Tag ===================
1|_
  <script>
    // your javascript code
  </script>
  - use this method if you have a special code for specific page 
2|_
  <script src="js_code_path"><script/> 
  - code can be used in different places
  - readable
  - fast for browser
# INFO: =========================================
- script can be written anyware you want, but there is a diff between <head>&<body>
- put <script> in header can cause two problems 
  1|-> if the script is large it will take too much time until it get's rendred
  2|-> looking for element in header by its id while it is part of body,
    browser won't be able to find it 
- The best place where you can put <script> in the end of <BODY> || <HTML> 

===={ js: Variables }===========================================================

# NOTE::> GLOBAL 
name = "oussama";

# NOTE::> 'var' keyword | GLOBAL 
var name = "oussama";

- var: keyword does not assign a default value for the var (garbage value)
- var is supported on all browser versions, use it if you want to support older V  

# NOTE:> 'let' keyword | >= ES6 
let name = "oussama"

=> Syntax:
  * keyword name = "oussama", age = 20; 

  * keyword name = "oussama",
            isWorking = true,
            age = 20;

  * keyword name;
    keyword isWorking;
    keyword age; 

    name = "oussama";
    isWorking = true;
    age = 20;

# NOTE:> 'const' keyword | >= ES6
const name = "oussama" 

- const value can't be changed later

# INFO:======================================================================== 
# using variable in javascript without assigning won't print a garbage value
# it will print 'undefined' 
# =============================================================================

===<{ js: Datatypes }>=========================================================
- Primitve Datatypes: Strings, Numbers (int, float, ...), Booleans
- Reference DataTypes: Objects, Functions, arrays 
- Special Datatypes: null, undefined 

> [ Numbers: ]
  * in javascript we have 3 types of numbers: 
    - Integer Numbers: 8 
    - Dicimal Numbers: 8.5
    - Exponential Nation (scientific notation): 20e5 or 20e-5 

# NOTE:  undefined & null
# undefined: variables does not have a default value (garbage value)
# null: variables has the value 0 or null in it's memory buffer
# HINT: operator typeof __var__ will give you the variables's datatype 
# WARNING: assigning undefined to a variable it will remove it from memory

===<{ js: operators }>============
> Arithmetic Operators (C/C++) 
  a ** b : a^b 

> Comparison Operators
  - === : equal value && equale type to 
  - !== : not equal value || not equal type 

# NOTE: ternay statment
Python: expression if condition else expression
C/C++/JS: (condition) ? expression: expression 

> Logical operators

> Bitwise operators

> assignment operators

> Type operators 
  - typeof __var__                  => return variable type
  - __var__ instance of <Datatype>  => return true/false, checks if it's instance from something  

===<{ statments: }>================
> if statment   C/C++ 
> switch case   C/C++

===<{ Loops: }>====================
> for (variable in object) {}   => loops over all attribues of object Or element of array 
> for (variable of iterable) {} => loops over all iterable objects (String)

===<{ js: Numbers }>============================================================
> in javascript whatever the type of number it will be stored in 64bit (8 Byte)
> js engine stores the number according to conecpt <Double Precision Floating Point>
> this concept is very simple we all know the concept of floating-point
  (single precision floating point) that is stored in 32 bit (less precision),
  but the double precision is stored in 62bit, as defined by the IEEE 754 standard.

> Single precesion: 1 bit (sign), 8 bits (exponent), 23 bits (mantissa)
Formula for Single Precision:
  (‚àí1)sign√ó1.mantissa√ó2(exponent‚àí127)

> Double precision: 1 bit (sign), 11 bits (exponent), 52 bits (mantissa)
Formula for Double Precision:
  (‚àí1)sign√ó1.mantissa√ó2(exponent‚àí1023)

# INFO: 
Floating-point (single precision) uses 32 bits and provides less precision (about 7 decimal digits), with a smaller range.
Double precision uses 64 bits and provides more precision (about 15-17 decimal digits), with a larger range.
- JavaScript uses double precision floating point for all its number types, allowing it to handle a wide range of values with relatively high precision. However, this can lead to rounding errors when dealing with very small or large numbers or performing certain calculations.
> Solution:
  - toFixed() => convert to fixed-point represenation 

# NOTE:
# Js engine use memory <Stack> for primitive datatypes (numbers, Strings, booleans)
# Js engine use memor <Heap> for reference data types (objects, arrays)

# HINT: understand immutable & mutable (python/javascript)
# immutable means it have fixed size, making them suitable for stack
# mmutable means their size can grow dynamically and may not be know at compile time

# INFO: 
# garbege collector mekhtalf chi chwiya 3la hadak li 3rafna fi C hada tayb9a ijma3 o
# o mli tayhess bi lmemory bdat kat3mar taydir chataba peridically (bi chakl dawri)

# HINT: Garbege collector (python vs javascript)
# python: Reference Counting  + Cyclic Garbage Collection
# js: Mark-and-Sweep Garbage Collection
# Refernce counting (internal reference counting) is used also by smart pointers

> Number limits
  Integers: 999...999 | 15 number

# INFO:
# '20' + 20             => 2020
# 20 + 20 + '20'        => 4020
# '20' + 20 + 20        => 202020 : '20' + (20 + 20) => 2040

# INFO:
# '10' + '5' = 105
# '10' - '5' = 5
# '10' * '5' = 50
# '10' / '5' = 2

# TIP:
- if the operations is not logical it will give the value NaN (Not a Number)
- it can be stored in var (typeof it will result NaN)
- use isNan() function to check if the value is NaN or not
- Infinity: when the number is too large, it will give infinity ex: 1e1000000

- Some useful functions
- toString()                : number to String
- Number(class).isFinite()  : check infinity
- Number.isInteger()        : if integer
- Number.isNan()            : check if NaN
- Number.parseInt(str)      : parse str to int
- Number.parseFloat()       : parse str to float 
- Math.random() * nbr       : generate random numbers  in range [0, nbr[
- Math.floor

> Constans (Limits)
- Number.MAX_SAFE_INTEGER
- Number.MIN_SAFE_INTEGER
- Numbers.MAX_VALUE 
- Numbers.MIN_VALUE
- Number.POSITIVE_INFINITY
- NUMBER.NEGATIVE_INFINITY

> Math class
- Math.abs()
...
> constants
- Math.PI
...


